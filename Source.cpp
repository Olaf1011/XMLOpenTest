#include "Header.h"

#include <sstream>
#include <algorithm>
#include <cassert>
#include <iostream>
#include <iterator>
#include <string>
#include <windows.h>

#include "tinyxml2.h"


using namespace tinyxml2;



std::vector<std::pair<float,float>> string_split(const std::string& s)
{
    size_t start = 0;
    size_t end = s.find_first_of(',');
    
    std::vector<std::pair<float, float>> output;
	
    while (end <= s.size())
    {
  	
	    output.emplace_back(
			std::make_pair(	
				stof(s.substr(start, end - start)),
				stof(s.substr(end + 1, s.find_first_of(' ', end + 1)))
				));

	    if (end >= s.size())
	    	break;

    	start = s.find_first_of(' ', end + 1);
    	end = s.find_first_of(',', start);
    }
	return output;
}


int ImportData::operator()()
{
	tinyxml2::XMLDocument XmlData;
	XmlData.LoadFile("ExportedData.xml");
	XMLNode* pRoot = XmlData.FirstChild();
	//Check if file is loaded correctly
	if (pRoot == nullptr)
		return XML_ERROR_FILE_READ_ERROR;


	XMLElement* sets = pRoot->FirstChildElement("Set");
	if (sets == nullptr)
		return XML_ERROR_PARSING_ELEMENT;

	LARGE_INTEGER qpc_freq;
	QueryPerformanceFrequency(&qpc_freq);

	// Convert timer frequency to floating point milliseconds
	volatile auto timer_multiplier = (double)qpc_freq.QuadPart;

	LARGE_INTEGER qpc_begin;
	QueryPerformanceCounter(&qpc_begin);



	std::vector<Data> result;
	while (sets != nullptr)
	{
		result.clear();
		mResult.push_back(string_split(sets->FirstChildElement("Coordinates")->GetText()));

		sets = sets->NextSiblingElement();

	}

	LARGE_INTEGER qpc_end;
	QueryPerformanceCounter(&qpc_end);

	
	volatile auto t = (double)(qpc_end.QuadPart - qpc_begin.QuadPart) / timer_multiplier;
	
	std::cout << t << std::endl;
	return XML_SUCCESS;
}

int main()
{
	ImportData ID;
	return (ID() == XML_SUCCESS);
}
